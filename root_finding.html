
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Root Finding &#8212; Introduction to Numerical Analysis I</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css?v=384b581d" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="_static/tabs.css?v=4c969af8" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae" />
  <script src="_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=8d27b9dea8ad943066ae"></script>

    <script src="_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=7f8ff830"></script>
    <script src="_static/scripts/sphinx-book-theme.js?v=efea14e4"></script>
    <script src="_static/tabs.js?v=3ee01567"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js?v=36754332"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"tex": {"macros": {"eps": "\\varepsilon", "cO": "\\mathcal{O}", "fl": ["\\textrm{fl}(#1)", 1], "N": "\\mathbb{N}", "floor": ["\\lfloor#1\\rfloor", 1], "bmat": ["\\left[\\begin{array}"], "emat": ["\\end{array}\\right]"]}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'root_finding';</script>
    <link rel="icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Interpolation" href="interpolation.html" />
    <link rel="prev" title="Floating Point Arithmetic" href="floating_point.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <header class="bd-header navbar navbar-expand-lg bd-navbar">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="index.html">
  
  
  
  
  
  
    <p class="title logo__title">Introduction to Numerical Analysis I</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Lecture notes</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="floating_point.html">Floating Point Arithmetic</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Root Finding</a></li>
<li class="toctree-l1"><a class="reference internal" href="interpolation.html">Interpolation</a></li>
<li class="toctree-l1"><a class="reference internal" href="differentiation_quadrature.html">Differentiation and Quadrature</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/root_finding.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Root Finding</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#bracket-methods">Bracket Methods</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bisection-method">Bisection Method</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#false-position-method">False Position Method</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#order-of-convergence">Order of Convergence</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#iterative-methods">Iterative Methods</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#newton-raphson-method">Newton-Raphson Method</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#secant-method">Secant Method</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#applications-in-optimization">Applications in Optimization</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">Exercises</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#theoretical-part">Theoretical Part</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#computational-part">Computational Part</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#extended-reading">Extended Reading</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="root-finding">
<h1>Root Finding<a class="headerlink" href="#root-finding" title="Link to this heading">#</a></h1>
<p>Root finding is a fundamental problem in numerical analysis and has many applications in science and engineering such as solving nonlinear equations, optimization problems, and differential equations. Usually, a closed form of the root is not available, and we need to compute the root numerically. In this chapter, we will discuss some of the most common methods for root finding.</p>
<section id="bracket-methods">
<h2>Bracket Methods<a class="headerlink" href="#bracket-methods" title="Link to this heading">#</a></h2>
<p>If <span class="math notranslate nohighlight">\(f\)</span> is a continuous function, and <span class="math notranslate nohighlight">\(f(a)\)</span> and <span class="math notranslate nohighlight">\(f(b)\)</span> have opposite signs, then by the Intermediate Value Theorem, there exists a root of <span class="math notranslate nohighlight">\(f\)</span> on the interval <span class="math notranslate nohighlight">\([a, b]\)</span>. The bracket method is based on this fact and iteratively locates the pair of points <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> such that <span class="math notranslate nohighlight">\(f(a)\)</span> and <span class="math notranslate nohighlight">\(f(b)\)</span> have opposite signs. The most common bracket methods are the bisection method and the false position method.</p>
<section id="bisection-method">
<h3>Bisection Method<a class="headerlink" href="#bisection-method" title="Link to this heading">#</a></h3>
<p>The simplest bracket method is the <strong>bisection method</strong>. Once <span class="math notranslate nohighlight">\(f(a)f(b) &lt; 0\)</span>, one can select the midpoint <span class="math notranslate nohighlight">\(c = \frac{a + b}{2}\)</span> and check the sign of <span class="math notranslate nohighlight">\(f(a) f(c)\)</span>.</p>
<ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(f(a)f(c) &lt; 0\)</span>, then the root is in the interval <span class="math notranslate nohighlight">\([a, c]\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(f(a)f(c) &gt; 0\)</span>, then the root is in the interval <span class="math notranslate nohighlight">\([c, b]\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(f(a)f(c) = 0\)</span>, then <span class="math notranslate nohighlight">\(c\)</span> is the root.</p></li>
</ul>
<aside class="margin sidebar">
<p class="sidebar-title">Iterative vs Recursive</p>
<p>The bisection method can be implemented either iteratively or recursively. The recursive program usually is more compact, but may suffer from inefficiency (more instructions) and the risk of stack overflow.</p>
<p>For a variety of programming languages, recursive implementation can be made more efficient by using the so called <strong>tail recursion optimization</strong>. This is a compiler feature that allows the recursive program to be executed with the same efficiency as the iterative one. However, neither <code class="docutils literal notranslate"><span class="pre">Python</span></code> nor <code class="docutils literal notranslate"><span class="pre">MATLAB</span></code> natively supports tail recursion optimization. : )</p>
</aside>
<p>For the first two cases, we can repeat the process with the new interval until certain stop criteria are met. Each iteration reduces the size of the interval by half (gaining one bit each iteration), the total number of iterations required to reduce the interval to a certain size is <span class="math notranslate nohighlight">\(\lceil\log_2\left(\frac{b - a}{\epsilon}\right)\rceil\)</span>, where <span class="math notranslate nohighlight">\(\epsilon\)</span> is the desired tolerance.</p>
<p>Once the function <span class="math notranslate nohighlight">\(f\)</span> has a sign change over the bracket <span class="math notranslate nohighlight">\([a, b]\)</span>, the bisection method is guaranteed to converge to a root, but it is not very efficient. It is usually used to obtain a rough estimate of the root, which is then taken as an initial guess for a more efficient method.</p>
</section>
<section id="false-position-method">
<h3>False Position Method<a class="headerlink" href="#false-position-method" title="Link to this heading">#</a></h3>
<p>The bisection method only uses <span class="math notranslate nohighlight">\(\text{sgn}(f(a))\)</span> and <span class="math notranslate nohighlight">\(\text{sgn}(f(b))\)</span> instead of the function values. The <strong>false position method</strong> (<em>Regula falsi</em> in Latin) improves the bisection method by taking the function values into account. Instead of selecting the midpoint <span class="math notranslate nohighlight">\(c = \frac{a + b}{2}\)</span>, the false position method selects the point <span class="math notranslate nohighlight">\(c\in[a, b]\)</span> that lies on the line connecting <span class="math notranslate nohighlight">\((a, f(a))\)</span> and <span class="math notranslate nohighlight">\((b, f(b))\)</span>, that is</p>
<div class="math notranslate nohighlight">
\[c = \frac{f(b) a - f(a) b}{f(b) - f(a)} = a - f(a)\frac{b - a}{f(b) - f(a)}.\]</div>
<p>The false position method is also guaranteed to converge to a root if <span class="math notranslate nohighlight">\(f(a)f(b) &lt; 0\)</span> and the implementation is quite similar to the bisection method. It usually converges faster than the bisection method, but sometimes exceptions occur.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When <span class="math notranslate nohighlight">\(f''\)</span> keeps the same sign over <span class="math notranslate nohighlight">\([a, b]\)</span>, it is not hard to show that only one side of the bracket is updating. The bracket size will never decrease to zero, which is different from the bisection method. In the following, we use an example to illustrate this, see <a class="reference internal" href="#root-finding-false-img"><span class="std std-numref">Fig. 1</span></a>. The function <span class="math notranslate nohighlight">\(f(x) = x^2 - 1\)</span> over the initial bracket <span class="math notranslate nohighlight">\([0, 2]\)</span>. The left endpoint is updating to the root while the right endpoint is fixed at <span class="math notranslate nohighlight">\(2\)</span>.</p>
<figure class="align-center" id="root-finding-false-img">
<a class="reference internal image-reference" href="_images/root_finding_img_0.png"><img alt="_images/root_finding_img_0.png" src="_images/root_finding_img_0.png" style="width: 427.20000000000005px; height: 330.40000000000003px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 1 </span><span class="caption-text">False position method</span><a class="headerlink" href="#root-finding-false-img" title="Link to this image">#</a></p>
</figcaption>
</figure>
</div>
<p>It is actually easy to improve the false position method by forcing more weight towards the other endpoint. This is called the <strong>Illinois method</strong>. Once the same side has updated in two consecutive iterations, the Illinois method will adjust <span class="math notranslate nohighlight">\(c\)</span> using a slightly different formula.</p>
<div class="math notranslate nohighlight">
\[
{c} = a - f(a)\frac{ b - a }{\lambda f(b) - f(a)}
\]</div>
<p>or</p>
<div class="math notranslate nohighlight">
\[
{c} =  b -  f(b) \frac{a - b}{\lambda f(a) - f(b)},
\]</div>
<p>where the weight <span class="math notranslate nohighlight">\(\lambda\)</span> controls the position of <span class="math notranslate nohighlight">\(c\)</span>. The weight is initially set to <span class="math notranslate nohighlight">\(1\)</span> which corresponds to the standard false position method. If the same side is about to update twice, the weight of the other side will be halved. If not, the weight on the new bracket point will be reset to <span class="math notranslate nohighlight">\(1\)</span>. See <a class="reference internal" href="#AL-ILLINOIS">Algorithm 2</a>.</p>
<aside class="margin sidebar">
<p class="sidebar-title"></p>
<p>The choice of decay factor <span class="math notranslate nohighlight">\(\frac{1}{2}\)</span> is optimal if it has to be a constant (explain later). The factor can be replaced with other variable values. A usual replacement is the <strong>Pegasus</strong> method.</p>
<p>Essentially, the <strong>Pegasus</strong> method replaces <span class="math notranslate nohighlight">\(\lambda = 1/2\)</span> with <span class="math notranslate nohighlight">\(\lambda=\frac{f_1}{f_1 + f_2}\)</span>.</p>
<!-- - **Anderson-Bjorck**: it is slightly different, instead of detecting two consecutive false position iterations on the same side, it will try to prevent two consecutive false position iterations on the same side by interchanging endpoints. Otherwise, it replace $\lambda_b \gets \lambda_b/2$ with $\lambda_b\gets \lambda_b m_b$ and replace $\lambda_a \gets \lambda_a/2$ with $\lambda_a\gets\lambda_a m_a$, where 

    $$m_a = \begin{cases}1 - \frac{f(c)}{f(b)} &\text{if positive}\\ \frac{1}{2} &\text{otherwise}\end{cases}$$

    $$m_b = \begin{cases}1 - \frac{f(c)}{f(a)} &\text{if positive}\\ \frac{1}{2} &\text{otherwise}\end{cases}$$
-->
</aside>
<div class="proof algorithm admonition" id="AL-ILLINOIS">
<p class="admonition-title"><span class="caption-number">Algorithm 2 </span> (Illinois Method)</p>
<section class="algorithm-content" id="proof-content">
<p><strong>Inputs</strong> <span class="math notranslate nohighlight">\(f\)</span>, <span class="math notranslate nohighlight">\(a, b\)</span>, <span class="math notranslate nohighlight">\(\epsilon\)</span></p>
<p><strong>Outputs</strong> <span class="math notranslate nohighlight">\(c\)</span></p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(x_0\gets a\)</span>, <span class="math notranslate nohighlight">\(x_1\gets b\)</span>, <span class="math notranslate nohighlight">\(f_0\gets f(x_0)\)</span>, <span class="math notranslate nohighlight">\(f_1\gets f(x_1)\)</span>. <span class="math notranslate nohighlight">\(iter = 0\)</span> //initialization.</p></li>
<li><p>While True do:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(x_2 \gets x_0 - f_0 \frac{x_1 - x_0}{f_1 - f_0}\)</span>, <span class="math notranslate nohighlight">\(f_2 \gets f(x_2)\)</span>, <span class="math notranslate nohighlight">\(iter \gets iter + 1\)</span>. //standard false position step, <span class="math notranslate nohighlight">\(x_1\)</span> and <span class="math notranslate nohighlight">\(x_2\)</span> are two latest iterations.</p></li>
<li><p>If <span class="math notranslate nohighlight">\( |f_2| &lt; \epsilon\)</span>, then return <span class="math notranslate nohighlight">\(x_2\)</span>; //check stopping criteria</p></li>
<li><p>While <span class="math notranslate nohighlight">\(f_1 f_2 &gt; 0\)</span>, then // adjust until the sign changes</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\((x_0, f_0)\gets (x_0, \lambda f_0)\)</span>, where <span class="math notranslate nohighlight">\(\lambda = \frac{1}{2}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\((x_1, f_1)\gets (x_2, f_2)\)</span> and  <span class="math notranslate nohighlight">\(x_2 \gets x_0 - f_0 \frac{x_1 - x_0}{f_1 - f_0}\)</span>, <span class="math notranslate nohighlight">\(f_2 \gets f(x_2)\)</span>,  <span class="math notranslate nohighlight">\(iter \gets iter + 1\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\( |f_2| &lt; \epsilon\)</span>, then return <span class="math notranslate nohighlight">\(x_2\)</span>; //check stopping criteria</p></li>
</ul>
</li>
<li><p>If <span class="math notranslate nohighlight">\(f_1 f_2 &lt; 0\)</span>, then // perform a false position step</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\((x_0, f_0)\gets (x_1, f_1)\)</span> and <span class="math notranslate nohighlight">\((x_1, f_1)\gets (x_2, f_2)\)</span>.</p></li>
</ul>
</li>
</ol>
</li>
</ol>
</section>
</div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>We use the previous example to illustrate the difference between the false position method and the Illinois method. At the second iteration, the Illinois method finds the updating is still on left side, so it modifies right endpoint <span class="math notranslate nohighlight">\(f(b)\)</span> into <span class="math notranslate nohighlight">\(\frac{1}{2} f(b)\)</span> to compute the new <span class="math notranslate nohighlight">\(c\)</span>, which makes the selected point <span class="math notranslate nohighlight">\({c}\)</span> closer to the right endpoint than the false position method, see <a class="reference internal" href="#root-finding-illinois-img"><span class="std std-numref">Fig. 2</span></a>.</p>
<figure class="align-center" id="root-finding-illinois-img">
<a class="reference internal image-reference" href="_images/root_finding_img_1.png"><img alt="_images/root_finding_img_1.png" src="_images/root_finding_img_1.png" style="width: 427.20000000000005px; height: 330.40000000000003px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 2 </span><span class="caption-text">Illinois method</span><a class="headerlink" href="#root-finding-illinois-img" title="Link to this image">#</a></p>
</figcaption>
</figure>
</div>
<aside class="margin sidebar">
<p class="sidebar-title">Stopping Criteria</p>
<p>There are several types of stopping criteria to terminate the iteration. Common ones include:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(|f(c)| &lt; \texttt{ftol}\)</span>, tolerance on the function value.</p></li>
<li><p><span class="math notranslate nohighlight">\(|c_n - c_{n-1}| &lt; \texttt{atol}\)</span>, absolute tolerance.</p></li>
<li><p><span class="math notranslate nohighlight">\(|c_n - c_{n-1}| &lt; \texttt{rtol} |c_n|\)</span>, relative tolerance.</p></li>
</ul>
</aside>
<div class="proof example admonition" id="example-1">
<p class="admonition-title"><span class="caption-number">Example 2 </span></p>
<section class="example-content" id="proof-content">
<p>Let us try the aforementioned methods to find the root of <span class="math notranslate nohighlight">\(f(x) = x^3 - 2x^2 - 4\)</span> on the interval <span class="math notranslate nohighlight">\([1, 3]\)</span>. The root <span class="math notranslate nohighlight">\(x^{\ast}\)</span> can be computed analytically through cubic root formula, which is roughly <code class="docutils literal notranslate"><span class="pre">2.5943130163548496</span></code>.</p>
<p>Using the previous methods, we obtain the sequence of selection <span class="math notranslate nohighlight">\(c_n\)</span> and the error <span class="math notranslate nohighlight">\(|c_n - x^{\ast}|\)</span>. The tolerance is set to <span class="math notranslate nohighlight">\(|f(c)| &lt; 10^{-6}\)</span>. The results are shown in the following table.</p>
<div class="sd-tab-set docutils">
<input checked="checked" id="sd-tab-item-0" name="sd-tab-set-0" type="radio">
</input><label class="sd-tab-label" for="sd-tab-item-0">
Bisection Method</label><div class="sd-tab-content docutils">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">iter</span>  <span class="mi">1</span> <span class="o">|</span> <span class="mf">2.0000000000000000000000000</span> <span class="o">|</span> <span class="mf">5.94e-01</span> 
<span class="nb">iter</span>  <span class="mi">2</span> <span class="o">|</span> <span class="mf">2.5000000000000000000000000</span> <span class="o">|</span> <span class="mf">9.43e-02</span> 
<span class="nb">iter</span>  <span class="mi">3</span> <span class="o">|</span> <span class="mf">2.7500000000000000000000000</span> <span class="o">|</span> <span class="mf">1.56e-01</span> 
<span class="nb">iter</span>  <span class="mi">4</span> <span class="o">|</span> <span class="mf">2.6250000000000000000000000</span> <span class="o">|</span> <span class="mf">3.07e-02</span> 
<span class="nb">iter</span>  <span class="mi">5</span> <span class="o">|</span> <span class="mf">2.5625000000000000000000000</span> <span class="o">|</span> <span class="mf">3.18e-02</span> 
<span class="nb">iter</span>  <span class="mi">6</span> <span class="o">|</span> <span class="mf">2.5937500000000000000000000</span> <span class="o">|</span> <span class="mf">5.63e-04</span> 
<span class="nb">iter</span>  <span class="mi">7</span> <span class="o">|</span> <span class="mf">2.6093750000000000000000000</span> <span class="o">|</span> <span class="mf">1.51e-02</span> 
<span class="nb">iter</span>  <span class="mi">8</span> <span class="o">|</span> <span class="mf">2.6015625000000000000000000</span> <span class="o">|</span> <span class="mf">7.25e-03</span> 
<span class="nb">iter</span>  <span class="mi">9</span> <span class="o">|</span> <span class="mf">2.5976562500000000000000000</span> <span class="o">|</span> <span class="mf">3.34e-03</span> 
<span class="nb">iter</span> <span class="mi">10</span> <span class="o">|</span> <span class="mf">2.5957031250000000000000000</span> <span class="o">|</span> <span class="mf">1.39e-03</span> 
<span class="nb">iter</span> <span class="mi">11</span> <span class="o">|</span> <span class="mf">2.5947265625000000000000000</span> <span class="o">|</span> <span class="mf">4.14e-04</span> 
<span class="nb">iter</span> <span class="mi">12</span> <span class="o">|</span> <span class="mf">2.5942382812500000000000000</span> <span class="o">|</span> <span class="mf">7.47e-05</span> 
<span class="nb">iter</span> <span class="mi">13</span> <span class="o">|</span> <span class="mf">2.5944824218750000000000000</span> <span class="o">|</span> <span class="mf">1.69e-04</span> 
<span class="nb">iter</span> <span class="mi">14</span> <span class="o">|</span> <span class="mf">2.5943603515625000000000000</span> <span class="o">|</span> <span class="mf">4.73e-05</span> 
<span class="nb">iter</span> <span class="mi">15</span> <span class="o">|</span> <span class="mf">2.5942993164062500000000000</span> <span class="o">|</span> <span class="mf">1.37e-05</span> 
<span class="nb">iter</span> <span class="mi">16</span> <span class="o">|</span> <span class="mf">2.5943298339843750000000000</span> <span class="o">|</span> <span class="mf">1.68e-05</span> 
<span class="nb">iter</span> <span class="mi">17</span> <span class="o">|</span> <span class="mf">2.5943145751953125000000000</span> <span class="o">|</span> <span class="mf">1.56e-06</span> 
<span class="nb">iter</span> <span class="mi">18</span> <span class="o">|</span> <span class="mf">2.5943069458007812500000000</span> <span class="o">|</span> <span class="mf">6.07e-06</span> 
<span class="nb">iter</span> <span class="mi">19</span> <span class="o">|</span> <span class="mf">2.5943107604980468750000000</span> <span class="o">|</span> <span class="mf">2.26e-06</span> 
<span class="nb">iter</span> <span class="mi">20</span> <span class="o">|</span> <span class="mf">2.5943126678466796875000000</span> <span class="o">|</span> <span class="mf">3.49e-07</span> 
<span class="nb">iter</span> <span class="mi">21</span> <span class="o">|</span> <span class="mf">2.5943136215209960937500000</span> <span class="o">|</span> <span class="mf">6.05e-07</span> 
<span class="nb">iter</span> <span class="mi">22</span> <span class="o">|</span> <span class="mf">2.5943131446838378906250000</span> <span class="o">|</span> <span class="mf">1.28e-07</span> 
<span class="nb">iter</span> <span class="mi">23</span> <span class="o">|</span> <span class="mf">2.5943129062652587890625000</span> <span class="o">|</span> <span class="mf">1.10e-07</span> 
<span class="nb">iter</span> <span class="mi">24</span> <span class="o">|</span> <span class="mf">2.5943130254745483398437500</span> <span class="o">|</span> <span class="mf">9.12e-09</span> 
</pre></div>
</div>
</div>
<input id="sd-tab-item-1" name="sd-tab-set-0" type="radio">
</input><label class="sd-tab-label" for="sd-tab-item-1">
False Position Method</label><div class="sd-tab-content docutils">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">iter</span>  <span class="mi">1</span> <span class="o">|</span> <span class="mf">2.0000000000000000000000000</span> <span class="o">|</span> <span class="mf">5.94e-01</span> 
<span class="nb">iter</span>  <span class="mi">2</span> <span class="o">|</span> <span class="mf">2.4444444444444446418174266</span> <span class="o">|</span> <span class="mf">1.50e-01</span> 
<span class="nb">iter</span>  <span class="mi">3</span> <span class="o">|</span> <span class="mf">2.5621621621621617492792211</span> <span class="o">|</span> <span class="mf">3.22e-02</span> 
<span class="nb">iter</span>  <span class="mi">4</span> <span class="o">|</span> <span class="mf">2.5876913365185605364615640</span> <span class="o">|</span> <span class="mf">6.62e-03</span> 
<span class="nb">iter</span>  <span class="mi">5</span> <span class="o">|</span> <span class="mf">2.5929610854818996301673906</span> <span class="o">|</span> <span class="mf">1.35e-03</span> 
<span class="nb">iter</span>  <span class="mi">6</span> <span class="o">|</span> <span class="mf">2.5940374914642010395482430</span> <span class="o">|</span> <span class="mf">2.76e-04</span> 
<span class="nb">iter</span>  <span class="mi">7</span> <span class="o">|</span> <span class="mf">2.5942568846837747997824408</span> <span class="o">|</span> <span class="mf">5.61e-05</span> 
<span class="nb">iter</span>  <span class="mi">8</span> <span class="o">|</span> <span class="mf">2.5943015817106331866170876</span> <span class="o">|</span> <span class="mf">1.14e-05</span> 
<span class="nb">iter</span>  <span class="mi">9</span> <span class="o">|</span> <span class="mf">2.5943106870264029950590157</span> <span class="o">|</span> <span class="mf">2.33e-06</span> 
<span class="nb">iter</span> <span class="mi">10</span> <span class="o">|</span> <span class="mf">2.5943125418534931370118102</span> <span class="o">|</span> <span class="mf">4.75e-07</span> 
<span class="nb">iter</span> <span class="mi">11</span> <span class="o">|</span> <span class="mf">2.5943129196954899384763849</span> <span class="o">|</span> <span class="mf">9.67e-08</span> 
</pre></div>
</div>
</div>
<input id="sd-tab-item-2" name="sd-tab-set-0" type="radio">
</input><label class="sd-tab-label" for="sd-tab-item-2">
Illinois Method</label><div class="sd-tab-content docutils">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">iter</span>  <span class="mi">1</span> <span class="o">|</span> <span class="mf">2.0000000000000000000000000</span> <span class="o">|</span> <span class="mf">5.94e-01</span> 
<span class="nb">iter</span>  <span class="mi">2</span> <span class="o">|</span> <span class="mf">2.6153846153846154187760931</span> <span class="o">|</span> <span class="mf">2.11e-02</span> 
<span class="nb">iter</span>  <span class="mi">3</span> <span class="o">|</span> <span class="mf">2.5847750865051901669744439</span> <span class="o">|</span> <span class="mf">9.54e-03</span> 
<span class="nb">iter</span>  <span class="mi">4</span> <span class="o">|</span> <span class="mf">2.5941951587569969106539247</span> <span class="o">|</span> <span class="mf">1.18e-04</span> 
<span class="nb">iter</span>  <span class="mi">5</span> <span class="o">|</span> <span class="mf">2.5944267005726100450146987</span> <span class="o">|</span> <span class="mf">1.14e-04</span> 
<span class="nb">iter</span>  <span class="mi">6</span> <span class="o">|</span> <span class="mf">2.5943130084597889606357057</span> <span class="o">|</span> <span class="mf">7.90e-09</span> 
</pre></div>
</div>
</div>
<input id="sd-tab-item-3" name="sd-tab-set-0" type="radio">
</input><label class="sd-tab-label" for="sd-tab-item-3">
More Digits</label><div class="sd-tab-content docutils">
<p>Using <code class="docutils literal notranslate"><span class="pre">bigfloat</span></code> package, it is possible to extract more digits to observe the dynamics of the convergence. For instance, by setting the precision to 900 bits, the Illinois method’s convergence is shown in the following table.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">iter</span>  <span class="mi">1</span> <span class="o">|</span> <span class="mf">2.0000000000000000000000000</span> <span class="o">|</span> <span class="mf">5.94e-01</span> 
<span class="nb">iter</span>  <span class="mi">2</span> <span class="o">|</span> <span class="mf">2.6153846153846154187760931</span> <span class="o">|</span> <span class="mf">2.11e-02</span> 
<span class="nb">iter</span>  <span class="mi">3</span> <span class="o">|</span> <span class="mf">2.5847750865051901669744439</span> <span class="o">|</span> <span class="mf">9.54e-03</span> 
<span class="nb">iter</span>  <span class="mi">4</span> <span class="o">|</span> <span class="mf">2.5941951587569973547431346</span> <span class="o">|</span> <span class="mf">1.18e-04</span> 
<span class="nb">iter</span>  <span class="mi">5</span> <span class="o">|</span> <span class="mf">2.5944267005726091568362790</span> <span class="o">|</span> <span class="mf">1.14e-04</span> 
<span class="nb">iter</span>  <span class="mi">6</span> <span class="o">|</span> <span class="mf">2.5943130084597889606357057</span> <span class="o">|</span> <span class="mf">7.90e-09</span> 
<span class="nb">iter</span>  <span class="mi">7</span> <span class="o">|</span> <span class="mf">2.5943130163543197674869134</span> <span class="o">|</span> <span class="mf">5.29e-13</span> 
<span class="nb">iter</span>  <span class="mi">8</span> <span class="o">|</span> <span class="mf">2.5943130163553775879847763</span> <span class="o">|</span> <span class="mf">5.29e-13</span> 
<span class="nb">iter</span>  <span class="mi">9</span> <span class="o">|</span> <span class="mf">2.5943130163548486777358448</span> <span class="o">|</span> <span class="mf">1.65e-25</span> 
<span class="nb">iter</span> <span class="mi">10</span> <span class="o">|</span> <span class="mf">2.5943130163548486777358448</span> <span class="o">|</span> <span class="mf">5.13e-38</span> 
<span class="nb">iter</span> <span class="mi">11</span> <span class="o">|</span> <span class="mf">2.5943130163548486777358448</span> <span class="o">|</span> <span class="mf">5.13e-38</span> 
<span class="nb">iter</span> <span class="mi">12</span> <span class="o">|</span> <span class="mf">2.5943130163548486777358448</span> <span class="o">|</span> <span class="mf">1.55e-75</span> 
<span class="nb">iter</span> <span class="mi">13</span> <span class="o">|</span> <span class="mf">2.5943130163548486777358448</span> <span class="o">|</span> <span class="mf">4.70e-113</span> 
<span class="nb">iter</span> <span class="mi">14</span> <span class="o">|</span> <span class="mf">2.5943130163548486777358448</span> <span class="o">|</span> <span class="mf">4.70e-113</span> 
<span class="nb">iter</span> <span class="mi">15</span> <span class="o">|</span> <span class="mf">2.5943130163548486777358448</span> <span class="o">|</span> <span class="mf">1.30e-225</span> 
</pre></div>
</div>
</div>
</div>
</section>
</div><div class="proof remark admonition" id="rmk:bracket-methods">
<p class="admonition-title"><span class="caption-number">Remark 2 </span></p>
<section class="remark-content" id="proof-content">
<p>The bracket methods need to first locate an interval <span class="math notranslate nohighlight">\([a, b]\)</span> such that <span class="math notranslate nohighlight">\(f(a)f(b) &lt; 0\)</span>. A common approach is to sample a few equidistant points in a large interval and then use the sign of the function values to identify the bracket. This is a simple and robust approach, but it may require a large number of function evaluations.</p>
</section>
</div></section>
<section id="order-of-convergence">
<h3>Order of Convergence<a class="headerlink" href="#order-of-convergence" title="Link to this heading">#</a></h3>
<p>The order of convergence quantifies how fast the sequence approximates the limiting value.</p>
<aside class="margin sidebar">
<p class="sidebar-title">More About Convergence</p>
<p>In practice, the limit or even upper bound may not exist for <span class="math notranslate nohighlight">\(\frac{|x_{n+1} - x^{\ast}|}{|x_n - x^{\ast}|^p}\)</span>, it is possible to consider the convergence rate in weaker sense. For instance, for sufficiently large <span class="math notranslate nohighlight">\(n\)</span> that the inequality</p>
<div class="math notranslate nohighlight">
\[
\lim_{k\to\infty}\sqrt[k]{\frac{|x_{n+k} - x^{\ast}|}{|x_n - x^{\ast}|^{p^k}}}= \rho
\]</div>
<p>holds for certain <span class="math notranslate nohighlight">\(p &gt; 0\)</span> and <span class="math notranslate nohighlight">\(\rho &gt; 0\)</span>, then the sequence has a mean order of convergence is <span class="math notranslate nohighlight">\(p\)</span> and a mean convergence rate <span class="math notranslate nohighlight">\(\rho\)</span>.</p>
<p>On averaged, each iteration contributes an order of <span class="math notranslate nohighlight">\(p\)</span> and a rate of <span class="math notranslate nohighlight">\(\rho\)</span>.</p>
</aside>
<div class="proof definition admonition" id="dfn-order-of-convergence">
<p class="admonition-title"><span class="caption-number">Definition 2 </span></p>
<section class="definition-content" id="proof-content">
<p>The order of convergence of a sequence <span class="math notranslate nohighlight">\(\{x_n\}\)</span> is <span class="math notranslate nohighlight">\(p &gt; 0\)</span> if</p>
<div class="math notranslate nohighlight">
\[
\lim_{n\to\infty}\frac{|x_{n+1} - x^{\ast}|}{|x_n - x^{\ast}|^p} = \rho,
\]</div>
<p>The constant <span class="math notranslate nohighlight">\(\rho\)</span> is the rate of convergence. If <span class="math notranslate nohighlight">\(p = 1\)</span>, the sequence is said to have linear convergence. If <span class="math notranslate nohighlight">\(p = 2\)</span>, the sequence is said to have quadratic convergence.</p>
<p>If the limit does not exist while the upper bound exists for sufficiently large <span class="math notranslate nohighlight">\(n\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\frac{|x_{n+1} - x^{\ast}|}{|x_n - x^{\ast}|^p} \le \rho,
\]</div>
<p>then the order of convergence is <strong>at least</strong> <span class="math notranslate nohighlight">\(p\)</span> and the rate of convergence is <strong>at most</strong> <span class="math notranslate nohighlight">\(\rho\)</span>.</p>
</section>
</div><div class="proof theorem admonition" id="thm-bisection-convergence">
<p class="admonition-title"><span class="caption-number">Theorem 4 </span></p>
<section class="theorem-content" id="proof-content">
<p>The bisection method has a linear convergence rate.</p>
</section>
</div><div class="proof admonition" id="proof">
<p>Proof. Without loss of generality, we may assume the initial bracket is on <span class="math notranslate nohighlight">\([0, 1]\)</span>. Let the root <span class="math notranslate nohighlight">\(x^{\ast} = 0.b_1 b_2\cdots\)</span> be the binary representation, then the sequence of bisection method can be written as</p>
<div class="math notranslate nohighlight">
\[
x_n = 0.b_1 b_2\cdots b_{n-1} 1,
\]</div>
<p>where <span class="math notranslate nohighlight">\(b_i\)</span> is the <span class="math notranslate nohighlight">\(i\)</span>-th bit of the binary representation. The error at the <span class="math notranslate nohighlight">\(n\)</span>-th iteration is</p>
<div class="math notranslate nohighlight">
\[\begin{split}|x_n - x^{\ast}| = |2^{-n} - \sum_{j\ge n} 2^{-j} b_j|=\begin{cases}\sum_{j&gt;n} 2^{-j}b_j &amp; \text{if } b_n=1\\\sum_{j&gt;n} 2^{-j}(1-b_j) &amp;\text{if }b_n=0\end{cases}\end{split}\]</div>
<p>For each <span class="math notranslate nohighlight">\(n\)</span> such that <span class="math notranslate nohighlight">\(b_n = 1\)</span> (similar argument holds for <span class="math notranslate nohighlight">\(b_n=0\)</span>), we can find <span class="math notranslate nohighlight">\(s\in\N\)</span> such that <span class="math notranslate nohighlight">\(b_{s+n} = 1\)</span>, otherwise we arrive at the exact solution.</p>
<div class="math notranslate nohighlight">
\[
\frac{|x_{n+k} - x^{\ast}|}{|x_n - x^{\ast}|} = \frac{\sum_{j&gt;n+k} 2^{-j} b_j }{\sum_{j&gt;n} 2^{-j}b_j} \le \frac{2^{-(n+k)}}{2^{-(n+s)}} =2^{s - k} \]</div>
<p>Therefore, the geometric mean of the convergence rate is bounded by <span class="math notranslate nohighlight">\(\frac{1}{2}\)</span>.</p>
<div class="math notranslate nohighlight">
\[
\rho =\lim_{k\to\infty} \sqrt[k]{\frac{|x_{n+k} - x^{\ast}|}{|x_n - x^{\ast}|}} \le \lim_{k\to\infty}2^{s/k}\frac{1}{2} =\frac{1}{2}.
\]</div>
</div>
<p>A common technique to study the order of convergence is to use the Taylor expansion. Let us use the Illinois method as an example.</p>
<div class="proof theorem admonition" id="thm-illinois-convergence">
<p class="admonition-title"><span class="caption-number">Theorem 5 </span></p>
<section class="theorem-content" id="proof-content">
<p>The order of convergence of the Illinois method is <span class="math notranslate nohighlight">\(\sqrt[3]{3}\)</span>.</p>
</section>
</div><aside class="margin sidebar">
<p class="sidebar-title">Big <span class="math notranslate nohighlight">\(O\)</span> Notation</p>
<p>The big <span class="math notranslate nohighlight">\(O\)</span> notation is used to describe the upper bound of a function. For instance, <span class="math notranslate nohighlight">\(f(x) = \cO(g(x))\)</span> means that there exists a constant <span class="math notranslate nohighlight">\(C\)</span> such that <span class="math notranslate nohighlight">\(|f(x)| \le C|g(x)|\)</span> for sufficiently large <span class="math notranslate nohighlight">\(x\)</span>.</p>
<p>Another notation is the big <span class="math notranslate nohighlight">\(\Theta\)</span> notation, which is used to describe the upper and lower bounds of a function. For instance, <span class="math notranslate nohighlight">\(f(x) = \Theta(g(x))\)</span> means that there exists constants <span class="math notranslate nohighlight">\(C_1\)</span> and <span class="math notranslate nohighlight">\(C_2\)</span> such that <span class="math notranslate nohighlight">\(C_1|g(x)| \le |f(x)| \le C_2|g(x)|\)</span> for sufficiently large <span class="math notranslate nohighlight">\(x\)</span>.</p>
</aside>
<aside class="margin sidebar">
<p class="sidebar-title">Selection of Decay Factor</p>
<p>In theory, any decay factor smaller than one would produce the same order of convergence. The decay factor <span class="math notranslate nohighlight">\(\frac{1}{2}\)</span> is optimal in the sense that any smaller factor will make the adjustment iteration move away from the root. While having a larger factor will not be efficient to reduce the bracket size.</p>
</aside>
<div class="proof admonition" id="proof">
<p>Proof. Let <span class="math notranslate nohighlight">\(f(x)\in C^2[a, b]\)</span> and <span class="math notranslate nohighlight">\(x^{\ast}\)</span> be the root. For simplicity, we assume the root is simple. Let <span class="math notranslate nohighlight">\(\ell(x)\)</span> be the linear interpolation of <span class="math notranslate nohighlight">\(f\)</span> at the bracket <span class="math notranslate nohighlight">\([a, b]\)</span>, the slope is <span class="math notranslate nohighlight">\(f'(\zeta)=\frac{f(b) - f(a)}{b -a}\)</span>, then</p>
<div class="math notranslate nohighlight">
\[
f(x) - \ell(x) = \frac{f''(\xi)}{2}(x - a)(x - b),
\]</div>
<p>therefore, the root satisfies <span class="math notranslate nohighlight">\(-\ell(x^{\ast}) = \frac{f''(\xi)}{2}(x^{\ast} - a)(x^{\ast} - b)\)</span>. Let <span class="math notranslate nohighlight">\(c\)</span> be the next iteration, then</p>
<div class="math notranslate nohighlight">
\[
-\ell(x^{\ast}) + \ell(c) = -(x^{\ast} - c) f'(\zeta) =  \frac{f''(\xi)}{2}(x^{\ast} - a)(x^{\ast} - b),
\]</div>
<p>which implies <span class="math notranslate nohighlight">\((x^{\ast} - c) = -\frac{f''(\xi)}{2 f'(\zeta)} (x^{\ast} - a)(x^{\ast} - b)\)</span>. When <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> are already near the root, the right-hand side has a fixed sign, which implies that using the unadjusted false position method, the new point <span class="math notranslate nohighlight">\(c\)</span> will always fall into a fixed side of the root.</p>
<p>Now, we consider the adjustment of the Illinois method. Without loss of generality, we assume that <span class="math notranslate nohighlight">\(c\)</span> falls into the left side of the root. Then the next iteration will be using the bracket <span class="math notranslate nohighlight">\([c, b]\)</span> with adjusted weight for <span class="math notranslate nohighlight">\(b\)</span>. The new point <span class="math notranslate nohighlight">\(c'\)</span> satisfies</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
c' - x^{\ast} &amp;= \frac{\frac{1}{2} f(b) (c - x^{\ast}) - f(c) (b - x^{\ast})}{\frac{1}{2} f(b) - f(c)}  = (c - x^{\ast}) - \frac{f(c)(b-x^{\ast})}{\frac{1}{2}f(b) - f(c)}
+ \frac{f(c)(c - x^{\ast})}{\frac{1}{2}f(b) - f(c)}\\
&amp;= (c - x^{\ast}) - \frac{2f(c)}{f(b)}(b - x^{\ast}) \frac{1}{1 - \frac{2f(c)}{f(b)}} + \frac{2f(c)}{f(b)}(c - x^{\ast}) \frac{1}{1 - \frac{2f(c)}{f(b)}}
\end{aligned}
\end{split}\]</div>
<p>Using Taylor expansion at <span class="math notranslate nohighlight">\(x^{\ast}\)</span>, since <span class="math notranslate nohighlight">\(f'\)</span> is bounded from below near the root,</p>
<div class="math notranslate nohighlight">
\[\begin{split}
 \begin{aligned}
 \frac{f(c)}{f(b)} &amp;= \frac{(c - x^{\ast}) + \cO(|c - x^{\ast}|^2)}{(b - x^{\ast}) + \cO(|b - x^{\ast}|^2)} = \frac{(c - x^{\ast})}{(b - x^{\ast})}\left(1 + \frac{\cO(|b-x^{\ast}|) + \cO(|c - x^{\ast}|)}{1 + \cO(|b-x^{\ast}|)}\right) \\&amp;= \frac{(c - x^{\ast})}{(b - x^{\ast})}\left(1 + \cO(|b-x^{\ast}|)\right) = \frac{f''(\xi)}{2 f'(\zeta)} (a - x^{\ast}) \left(1 + \cO(|b-x^{\ast}|)\right)  .
 \end{aligned}
 \end{split}\]</div>
<p>Therefore, we obtain</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
c' - x^{\ast} &amp;= (c- x^{\ast}) + 2(x^{\ast} - c)\left(1 + \cO(|a - x^{\ast}|)\right) + \cO(|a - x^{\ast}||c - x^{\ast}|) \\
&amp;= (x^{\ast} - c)(1 + \cO(|a - x^{\ast}|)),
\end{aligned}
\end{split}\]</div>
<p>which moves the new point to the other side of the root by almost reflection. The next bracket becomes <span class="math notranslate nohighlight">\([c, c']\)</span> such that <span class="math notranslate nohighlight">\(|c - x^{\ast}|\approx |c' - x^{\ast}|\)</span>. Therefore, if denote the last two points as <span class="math notranslate nohighlight">\(c = x_{n}\)</span> and <span class="math notranslate nohighlight">\(c'=x_{n+1}\)</span>, then <span class="math notranslate nohighlight">\(|x_{n} - x^{\ast}|\approx |x_{n+1} - x^{\ast}|\)</span>, currently <span class="math notranslate nohighlight">\(c'\)</span> is on the right side of the root. The next three iterations satisfy</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(|x_{n+2} - x^{\ast}| = \Theta(|x_n - x^{\ast}| |x_{n+1} - x^{\ast}|) = \Theta(|x_{n+1} - x^{\ast}|^2) \)</span>, the iteration <span class="math notranslate nohighlight">\(x_{n+2}\)</span> is on left side.</p></li>
<li><p><span class="math notranslate nohighlight">\(|x_{n+3} - x^{\ast}| = \Theta(|x_{n+2} - x^{\ast}||x_{n+1} - x^{\ast}|) = \Theta(|x_{n+1} - x^{\ast}|^3)\)</span>, the iteration <span class="math notranslate nohighlight">\(x_{n+3}\)</span> is on left side, now two consecutive iterations on left side</p></li>
<li><p><span class="math notranslate nohighlight">\(|x_{n+4} - x^{\ast}| = \Theta(|x_{n+3} - x^{\ast}|) = \Theta(|x_{n+1} - x^{\ast}|^3)\)</span>, adjusted by Illinois method, the iteration <span class="math notranslate nohighlight">\(x_{n+4}\)</span> is on right side, which completes a cycle.</p></li>
</ul>
<p>By the previous definition of order of convergence, the Illinois method has an order of convergence <span class="math notranslate nohighlight">\(\sqrt[3]{3}\)</span>.</p>
</div>
<div class="proof remark admonition" id="rmk-illinois-convergence">
<p class="admonition-title"><span class="caption-number">Remark 3 </span></p>
<section class="remark-content" id="proof-content">
<p>A quick way of proof uses the asymptotic analysis.</p>
<p>If we denote <span class="math notranslate nohighlight">\(\epsilon_{n} =x_n - x^{\ast}\)</span>, then if <span class="math notranslate nohighlight">\(\epsilon_{i} &gt; 0\)</span> and <span class="math notranslate nohighlight">\(\epsilon_{i-1} &lt; 0\)</span>, then <span class="math notranslate nohighlight">\(\epsilon_{i+1} \simeq C \epsilon_{i}\epsilon_{i-1}\)</span>, where <span class="math notranslate nohighlight">\(C\approx \frac{f''(x^{\ast})}{2f'(x^{\ast})}\)</span>, here we may assume <span class="math notranslate nohighlight">\(C &gt; 0\)</span>, then <span class="math notranslate nohighlight">\(\epsilon_{i+1} &lt; 0\)</span>.</p>
<p>The next iteration applies the same rule, which is <span class="math notranslate nohighlight">\(\epsilon_{i+2} \simeq C \epsilon_{i+1}\epsilon_{i} = C^2 \epsilon_i^2 \epsilon_{i-1} &lt; 0\)</span>.</p>
<p>Now, we need an adjustment step, which gives <span class="math notranslate nohighlight">\(\epsilon_{i+3} = -C^2 \epsilon_i^2 \epsilon_{i-1} &gt; 0\)</span>, which completes a cycle. Every three iterations make a cycle, to derive the order of convergence, we continue to derive <span class="math notranslate nohighlight">\(\epsilon_{i+6}\)</span>, which equals to <span class="math notranslate nohighlight">\(-C^8\epsilon_{i}^6\epsilon_{i-1}^3 = C^2\epsilon_{i+3}^3\)</span>.</p>
<p>Therefore, the order of convergence is <span class="math notranslate nohighlight">\(\sqrt[3]{3}\)</span>.</p>
</section>
</div><p>By taking the decay factor as a constant, the order of convergence is at most <span class="math notranslate nohighlight">\(\sqrt[3]{3}\)</span>. However, if the decay factor can be chosen as a variable one, the order of convergence can be improved. Next, we apply the same technique to analyze the Pegasus method, which is a variant of the Illinois method. It is interesting that the Pegasus method was initially discovered in a subroutine for the <strong>Ferranti Pegasus</strong> computer, but no author information is included. The convergence analysis was given by <span id="id1">[<a class="reference internal" href="#id8" title="M Dowell and P Jarratt. The “pegasus” method for computing the root of an equation. BIT Numerical Mathematics, 12:503–508, 1972.">Dowell and Jarratt, 1972</a>]</span> after its discovery.</p>
<div class="proof theorem admonition" id="thm-pegasus-convergence">
<p class="admonition-title"><span class="caption-number">Theorem 6 </span> (Pegasus Method)</p>
<section class="theorem-content" id="proof-content">
<p>The Pegasus method is a variant of Illinois method, whose updating scheme for the decay factors is replaced by</p>
<div class="math notranslate nohighlight">
\[\lambda=\frac{f_1}{f_1+f_2}\]</div>
<p>in <a class="reference internal" href="#AL-ILLINOIS">Algorithm 2</a>. Then the order of convergence is <span class="math notranslate nohighlight">\(\sqrt[4]{\frac{7+\sqrt{57}}{2}}\)</span>.</p>
</section>
</div><div class="proof admonition" id="proof">
<p>Proof. Similar to the previous <a class="reference internal" href="#rmk-illinois-convergence">Remark 3</a>, we assume <span class="math notranslate nohighlight">\(\epsilon_{i-1} &lt; 0\)</span> and <span class="math notranslate nohighlight">\(\epsilon_{i} &gt; 0\)</span> such that <span class="math notranslate nohighlight">\(|\epsilon_i|\ll |\epsilon_{i-1}|\)</span>, the constant <span class="math notranslate nohighlight">\(C = \frac{f''}{2f'}|_{x=x^{\ast}} &gt; 0\)</span>.
Similar to the previous analysis, we can derive more terms in the asymptotic form</p>
<div class="math notranslate nohighlight">
\[
\epsilon_{i+1}\simeq C \epsilon_{i}\epsilon_{i-1} + D \epsilon_{i} \epsilon_{i-1}(\epsilon_{i} + \epsilon_{i-1})&lt; 0
\]</div>
<p>where <span class="math notranslate nohighlight">\(D = -C^2 + \frac{f'''}{6f'}|_{x=x^{\ast}}\)</span>. Then due to a different sign for <span class="math notranslate nohighlight">\(\epsilon_{i}\)</span> and <span class="math notranslate nohighlight">\(\epsilon_{i+1}\)</span>, we can derive</p>
<div class="math notranslate nohighlight">
\[\epsilon_{i+2}\simeq C \epsilon_{i+1}\epsilon_{i} + D \epsilon_{i+1} \epsilon_{i}(\epsilon_{i+1} + \epsilon_{i}) &lt; 0.\]</div>
<p>Now use the adjustment step, we obtain (needs some calculation)</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\epsilon_{i+3} &amp;= \frac{\epsilon_{i+2}\lambda f(x_i) - \epsilon_i f(x_{i+2})}{\lambda f(x_{i}) - f(x_{i+2})},\quad \lambda = \frac{f(x_{i+1})}{f(x_{i+2}) + f(x_{i+1})}\\
&amp;\approx C^2 \epsilon_{i}^2\epsilon_{i+2} - D \epsilon_{i} \epsilon_{i+1} \epsilon_{i+2}, 
\end{aligned}
\end{split}\]</div>
<p>it implies <span class="math notranslate nohighlight">\(\epsilon_{i+3} &lt; 0\)</span> as well. Therefore, another adjustment step is needed and (after some more calculations, see <a class="reference internal" href="#rmk-pegasus-asymptotic">Remark 4</a>)</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\epsilon_{i+4} &amp;=  \frac{\epsilon_{i+3}\lambda f(x_i) - \epsilon_i f(x_{i+3})}{\lambda f(x_{i}) - f(x_{i+3})},\quad \lambda = \frac{f(x_{i+2})}{f(x_{i+3}) + f(x_{i+2})}\frac{f(x_{i+1})}{f(x_{i+2}) + f(x_{i+1})}\\
&amp;\approx C^5 \epsilon_{i}^4\epsilon_{i+1}^2 &gt; 0.
\end{aligned}
\end{split}\]</div>
<p>Therefore, <span class="math notranslate nohighlight">\(\epsilon_{i+4}\approx C \epsilon_{i+3} \epsilon_{i+2}\)</span>. A full cycle consists of 4 iterations and</p>
<div class="math notranslate nohighlight">
\[
\epsilon_{i+8} \simeq C^7 \epsilon_{i+4}^6 \epsilon_{i+3}^2 \simeq C^{8}\epsilon_{i+4}^7 \epsilon_i^2.
\]</div>
<p>The order of convergence <span class="math notranslate nohighlight">\(p\)</span> solves <span class="math notranslate nohighlight">\(p^2 - 7p - 2 = 0\)</span>, which gives <span class="math notranslate nohighlight">\(p = \sqrt[4]{\frac{7+\sqrt{57}}{2}}\)</span>.</p>
</div>
<div class="proof remark admonition" id="rmk-pegasus-asymptotic">
<p class="admonition-title"><span class="caption-number">Remark 4 </span></p>
<section class="remark-content" id="proof-content">
<p>Actually, the asymptotic expansion of <span class="math notranslate nohighlight">\(\epsilon_{i+4}\)</span> is (expanded in <span class="math notranslate nohighlight">\(\epsilon_{i+1}\)</span> first )</p>
<div class="math notranslate nohighlight">
\[
\epsilon_{i+4} = C^5 \epsilon_{i}^4\epsilon_{i+1}^2 + C^7 \epsilon_i^7\epsilon_{i+1}
+ \cO(\epsilon_{i}^8 \epsilon_{i+1} + \epsilon_{i}^5 \epsilon_{i+1}^2 + \epsilon_{i}^3 \epsilon_{i+1}^3)\]</div>
<p>It is at first not clear why we can retain the first term and drop the rest, because it requires the following inequalities to hold</p>
<div class="math notranslate nohighlight">
\[\epsilon_{i}^3 \ll \epsilon_{i+1}\ll \epsilon_i.\]</div>
<p>The latter one is correct because of the relation <span class="math notranslate nohighlight">\(\epsilon_{i+1} \simeq C \epsilon_{i}\epsilon_{i-1} \ll \epsilon_i\)</span> once the iterations are close to the root. The former one is equivalent to <span class="math notranslate nohighlight">\(\epsilon_{i}^2 \ll \epsilon_{i-1}\)</span>. This can be made into an assumption because <span class="math notranslate nohighlight">\(\epsilon_{i-1}\)</span> and <span class="math notranslate nohighlight">\(\epsilon_{i}\)</span> are the last two iterations in the previous cycle, which correspond to <span class="math notranslate nohighlight">\(\epsilon_{i+3}\)</span> and <span class="math notranslate nohighlight">\(\epsilon_{i+4}\)</span> in the current cycle, we can use the above asymptotic estimate to find <span class="math notranslate nohighlight">\(\epsilon_{i+3}^3 \approx C^6 \epsilon_{i}^9 \epsilon_{i+1}^3 \ll \epsilon_{i+4}\)</span>.</p>
<p>Therefore, if the inequality does not hold, one can use the current cycle as the starting point to perform the same analysis.</p>
</section>
</div><p>In the Pegasus method, two consecutive standard false position steps and two adjustment steps are performed in a full cycle. Although the decay over a full cycle is significant, such advantage will be gone if the cycle is long.</p>
<p>In order to make the cycle shorter, we need to drop at least one step. According to the previous analysis (see Illinois method), the standard false position step does not change the sign of the error asymptotically, thus it is preferred to drop one of the standard false position steps.</p>
<p>Let us finish this section with a brief discussion on the <strong>improved Pegasus</strong> method <span id="id2">[<a class="reference internal" href="#id9" title="Richard F King. An improved pegasus method for root finding. BIT Numerical Mathematics, 13:423–427, 1973.">King, 1973</a>]</span>, which takes the advantage of the symmetry in the false position method to avoid consecutive standard false position steps. The similar technique can be also applied to other methods such as <strong>Anderson-Bjorck</strong> method <span id="id3">[<a class="reference internal" href="#id10" title="Ned Anderson and Åke Björck. A new high order method of regula falsi type for computing a root of an equation. BIT Numerical Mathematics, 13(3):253–264, 1973.">Anderson and Björck, 1973</a>]</span>.</p>
<aside class="margin sidebar">
<p class="sidebar-title"></p>
<p>The <strong>Improved Pegasus</strong> method can also use the decay factor of <strong>Anderson-Bjorck</strong> method as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\lambda = \begin{cases} 1 - \frac{f_2}{f_1}&amp;\text{ if positive},\\
        \frac{1}{2}&amp;\text{ otherwise}.\end{cases}
\end{split}\]</div>
</aside>
<div class="proof algorithm admonition" id="AL-IMPROVED-PEGASUS">
<p class="admonition-title"><span class="caption-number">Algorithm 3 </span> (Improved Pegasus Method)</p>
<section class="algorithm-content" id="proof-content">
<p><strong>Inputs</strong> <span class="math notranslate nohighlight">\(f\)</span>, <span class="math notranslate nohighlight">\(a, b\)</span>, <span class="math notranslate nohighlight">\(\epsilon\)</span></p>
<p><strong>Outputs</strong> <span class="math notranslate nohighlight">\(c\)</span></p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(x_0\gets a\)</span>, <span class="math notranslate nohighlight">\(x_1\gets b\)</span>, <span class="math notranslate nohighlight">\(f_0\gets f(x_0)\)</span>, <span class="math notranslate nohighlight">\(f_1\gets f(x_1)\)</span>, <span class="math notranslate nohighlight">\(iter = 0\)</span>.  //initialization.</p></li>
<li><p>While True do:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(x_2 \gets x_0 - f_0 \frac{x_1 - x_0}{f_1 - f_0}\)</span>, <span class="math notranslate nohighlight">\(f_2 \gets f(x_2)\)</span>, <span class="math notranslate nohighlight">\(iter \gets iter + 1\)</span>. //standard false position step, <span class="math notranslate nohighlight">\(x_1\)</span> and <span class="math notranslate nohighlight">\(x_2\)</span> are two latest iterations.</p></li>
<li><p>If <span class="math notranslate nohighlight">\( |f_2| &lt; \epsilon\)</span>, then return <span class="math notranslate nohighlight">\(x_2\)</span>; //check stopping criteria</p></li>
<li><p>If <span class="math notranslate nohighlight">\(f_1 f_2 &lt; 0\)</span>, then swap <span class="math notranslate nohighlight">\((x_0, f_0)\)</span> and <span class="math notranslate nohighlight">\((x_1, f_1)\)</span>. // avoid false position step</p></li>
<li><p>While <span class="math notranslate nohighlight">\(f_1 f_2 &gt; 0\)</span>, then // adjust until the sign changes</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\((x_0, f_0)\gets (x_0, \lambda f_0)\)</span>, where <span class="math notranslate nohighlight">\(\lambda =\frac{f_1}{f_1 + f_2}\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\((x_1, f_1)\gets (x_2, f_2)\)</span> and  <span class="math notranslate nohighlight">\(x_2 \gets x_0 - f_0 \frac{x_1 - x_0}{f_1 - f_0}\)</span>, <span class="math notranslate nohighlight">\(f_2 \gets f(x_2)\)</span>, <span class="math notranslate nohighlight">\(iter\gets iter + 1\)</span></p></li>
<li><p>If <span class="math notranslate nohighlight">\( |f_2| &lt; \epsilon\)</span>, then return <span class="math notranslate nohighlight">\(x_2\)</span>; //check stopping criteria</p></li>
</ul>
</li>
<li><p>If <span class="math notranslate nohighlight">\(f_1 f_2 &lt; 0\)</span>, then // perform a false position step</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\((x_0, f_0)\gets (x_1, f_1)\)</span> and <span class="math notranslate nohighlight">\((x_1, f_1)\gets (x_2, f_2)\)</span>.</p></li>
</ul>
</li>
</ol>
</li>
</ol>
</section>
</div><div class="proof theorem admonition" id="thm-improved-pegasus-convergence">
<p class="admonition-title"><span class="caption-number">Theorem 7 </span></p>
<section class="theorem-content" id="proof-content">
<p>The <strong>improved Pegasus</strong> method has an order of convergence at least <span class="math notranslate nohighlight">\(\sqrt[3]{5}\)</span>.</p>
</section>
</div><div class="proof admonition" id="proof">
<p>Proof. In the same setting as the previous theorem, we will find the first iteration is the same as the Pegasus method (false position) that</p>
<div class="math notranslate nohighlight">
\[\epsilon_{i+1}\simeq C \epsilon_i \epsilon_{i-1} + D \epsilon_i \epsilon_{i-1}(\epsilon_{i} + \epsilon_{i-1}) &lt; 0.\]</div>
<p>For the second iteration, although <span class="math notranslate nohighlight">\(x_{i+1}\)</span> and <span class="math notranslate nohighlight">\(x_{i}\)</span> are on different sides, but a false position step has been performed in the previous step, thus it will perform adjustment step with <span class="math notranslate nohighlight">\(\lambda = \frac{f(x_{i}) - f(x_{i+1})}{f(x_{i})}\)</span>, then</p>
<div class="math notranslate nohighlight">
\[\epsilon_{i+2} \simeq -D \epsilon_{i+1}\epsilon_{i}\epsilon_{i-1},\]</div>
<p>note the leading term is different from the Pegasus method. There are two options.</p>
<ul>
<li><p>If <span class="math notranslate nohighlight">\(D &lt; 0\)</span>, then <span class="math notranslate nohighlight">\(\epsilon_{i+2} &gt; 0\)</span> which completes a cycle with two iterations, which is very compact. In this case, we find</p>
<div class="math notranslate nohighlight">
\[\epsilon_{i+4} \simeq C^{2}  \epsilon_{i+2}^3,\]</div>
<p>which implies an order of convergence at <span class="math notranslate nohighlight">\(\sqrt{3}\)</span>.</p>
</li>
<li><p>If <span class="math notranslate nohighlight">\(D &gt; 0\)</span>, then it will perform another adjustment step,</p>
<div class="math notranslate nohighlight">
\[\epsilon_{i+3} =  \frac{\epsilon_{i+2}\lambda f(x_i) - \epsilon_i f(x_{i+2})}{\lambda f(x_{i}) - f(x_{i+2})},\quad \lambda = \frac{f(x_{i+1})-f(x_{i+2})}{f(x_{i+1})}\frac{f(x_{i})-f(x_{i+1}) }{ f(x_{i})}\]</div>
<p>which will make <span class="math notranslate nohighlight">\(\epsilon_{i+3} \simeq -C^3 D \epsilon_{i-1}^3 \epsilon_i^3 &gt; 0\)</span>, which completes a cycle with three iterations. In this case, we find</p>
<div class="math notranslate nohighlight">
\[\epsilon_{i+6} \simeq D^{2}  \epsilon_{i+3}^5,\]</div>
<p>which implies an order of convergence at <span class="math notranslate nohighlight">\(\sqrt[3]{5}\)</span>.</p>
</li>
</ul>
</div>
</section>
</section>
<section id="iterative-methods">
<h2>Iterative Methods<a class="headerlink" href="#iterative-methods" title="Link to this heading">#</a></h2>
<p>In theory, the bracket methods are also <em>iterative</em>. However, one important phenomenon of bracket methods is that the current iteration may <strong>not</strong> be generated by the latest iterations. For instance, the false position method will have a stalled endpoint once the iterations are near the root.</p>
<p>In the following, we will introduce some iterative methods, which generates new iterations based on the latest iterations.</p>
<section id="newton-raphson-method">
<h3>Newton-Raphson Method<a class="headerlink" href="#newton-raphson-method" title="Link to this heading">#</a></h3>
<p>Let <span class="math notranslate nohighlight">\(f\in C^2\)</span>, if the current iteration <span class="math notranslate nohighlight">\(x_{n}\)</span> is close to a root, then the Newton-Raphson method computes the next iteration <span class="math notranslate nohighlight">\(x_{n+1}\)</span> by</p>
<div class="math notranslate nohighlight">
\[
x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}.
\]</div>
<p>Geometrically, <span class="math notranslate nohighlight">\(x_{n+1}\)</span> is the <span class="math notranslate nohighlight">\(x\)</span>-intercept of the tangent line of <span class="math notranslate nohighlight">\(f\)</span> at <span class="math notranslate nohighlight">\((x_n, f(x_n))\)</span>. Asymptotically, the Newton-Raphson method has a quadratic convergence rate if the root is simple.</p>
<figure class="align-center" id="root-finding-img-newton-raphson">
<a class="reference internal image-reference" href="_images/root_finding_img_2.png"><img alt="_images/root_finding_img_2.png" src="_images/root_finding_img_2.png" style="width: 427.20000000000005px; height: 330.40000000000003px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 3 </span><span class="caption-text">Newton-Raphson method</span><a class="headerlink" href="#root-finding-img-newton-raphson" title="Link to this image">#</a></p>
</figcaption>
</figure>
<aside class="margin sidebar">
<p class="sidebar-title">Limitation</p>
<p>The analysis can only provide convergence for the initial guess close to the root. If the initial guess is far from the root, then it is possible that the sequence diverges.</p>
</aside>
<div class="proof theorem admonition" id="thm-newton-raphson-convergence">
<p class="admonition-title"><span class="caption-number">Theorem 8 </span></p>
<section class="theorem-content" id="proof-content">
<p>Suppose <span class="math notranslate nohighlight">\(f\in C^2\)</span> and the root is simple, then the order of convergence for Newton-Raphson method is 2.</p>
</section>
</div><div class="proof admonition" id="proof">
<p>Proof. The Taylor expansion of <span class="math notranslate nohighlight">\(f\)</span> at <span class="math notranslate nohighlight">\(x_n\)</span> is</p>
<div class="math notranslate nohighlight">
\[f(x) = f(x_n) + f'(x_n)(x - x_n) + \frac{f''(\zeta)}{2}(x - x_n)^2\]</div>
<p>where <span class="math notranslate nohighlight">\(\zeta\in (x, x_n)\)</span>. The root is <span class="math notranslate nohighlight">\(x^{\ast}\)</span>, then <span class="math notranslate nohighlight">\(f(x^{\ast}) = 0\)</span>, thus</p>
<div class="math notranslate nohighlight">
\[0 = f(x_n) + f'(x_n)(x^{\ast} - x_n) + \frac{f''(\zeta)}{2}(x^{\ast} - x_n)^2.\]</div>
<p>Therefore,</p>
<div class="math notranslate nohighlight">
\[
-\frac{f''(\zeta)}{f'(x_n)} (x^{\ast} - x_n)^2= x^{\ast} - x_n + \frac{f(x_n)}{f'(x_n)} = x^{\ast} - x_{n+1}.
\]</div>
<p>If we denote the error <span class="math notranslate nohighlight">\(\epsilon_{n} = x_n - x^{\ast}\)</span>, then <span class="math notranslate nohighlight">\(\epsilon_{n+1} = \frac{f''(\zeta)}{f'(x_n)} \epsilon_{n}^2\)</span>, which implies the order of convergence is 2.</p>
</div>
</section>
<section id="secant-method">
<h3>Secant Method<a class="headerlink" href="#secant-method" title="Link to this heading">#</a></h3>
<p>The secant method is similar to the false position method, but it always uses the latest two iterations to perform the next iteration. The secant method computes the next iteration <span class="math notranslate nohighlight">\(x_{n+1}\)</span> by</p>
<div class="math notranslate nohighlight">
\[
x_{n+1} = x_n - f(x_n)\frac{x_n - x_{n-1}}{f(x_n) - f(x_{n-1})}.
\]</div>
<p>Using the same derivation for the Illinois method, the error <span class="math notranslate nohighlight">\(\epsilon_{n} = x_n - x^{\ast}\)</span> satisfies <span class="math notranslate nohighlight">\(\epsilon_{n+1} \simeq C \epsilon_{n}\epsilon_{n-1}\)</span>, see <a class="reference internal" href="#root-finding-img-secant"><span class="std std-numref">Fig. 4</span></a>.</p>
<figure class="align-center" id="root-finding-img-secant">
<a class="reference internal image-reference" href="_images/root_finding_img_3.png"><img alt="_images/root_finding_img_3.png" src="_images/root_finding_img_3.png" style="width: 427.20000000000005px; height: 330.40000000000003px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 4 </span><span class="caption-text">Secant method</span><a class="headerlink" href="#root-finding-img-secant" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The order of convergence <span class="math notranslate nohighlight">\(p\)</span> solves the equation <span class="math notranslate nohighlight">\(p^2 - p - 1 = 0\)</span>, which gives <span class="math notranslate nohighlight">\(p = \frac{1 + \sqrt{5}}{2}\)</span>.</p>
</section>
</section>
<section id="applications-in-optimization">
<h2>Applications in Optimization<a class="headerlink" href="#applications-in-optimization" title="Link to this heading">#</a></h2>
</section>
<section id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Link to this heading">#</a></h2>
<section id="theoretical-part">
<h3>Theoretical Part<a class="headerlink" href="#theoretical-part" title="Link to this heading">#</a></h3>
<div class="admonition-problem-1 admonition">
<p class="admonition-title">Problem 1</p>
<p>Briefly explain why the formula <span class="math notranslate nohighlight">\(x_2 = x_0 - f_0 \frac{x_1 - x_0}{f_1 - f_0}\)</span> in bracket methods will not suffer from catastrophic cancellation.</p>
</div>
<div class="admonition-problem-2 admonition">
<p class="admonition-title">Problem 2</p>
<p>The only difference between <a class="reference internal" href="#AL-IMPROVED-PEGASUS">Algorithm 3</a> and the usual Pegasus method is at the 3rd step in the while loop, which eliminates consecutive false position steps. This change is very simple, but it leads to an improvement in the order of convergence.</p>
<p>Explain why the Illinois method <span class="math notranslate nohighlight">\(\lambda = \frac{1}{2}\)</span> cannot be faster by the same technique.</p>
</div>
<div class="admonition-problem-3 admonition">
<p class="admonition-title">Problem 3</p>
<p>Suppose <span class="math notranslate nohighlight">\(f\in C^2\)</span> and the root <span class="math notranslate nohighlight">\(x^{\ast}\)</span> has a multiplicity of <span class="math notranslate nohighlight">\(m&gt;1\)</span>, then the order of convergence for the Newton-Raphson method is <span class="math notranslate nohighlight">\(1\)</span>. The modified Newton-Raphson method</p>
<div class="math notranslate nohighlight">
\[
x_{n+1} = x_n - m\frac{f(x_n)}{f'(x_n)}
\]</div>
<p>has an order of convergence <span class="math notranslate nohighlight">\(2\)</span>.</p>
</div>
</section>
<section id="computational-part">
<h3>Computational Part<a class="headerlink" href="#computational-part" title="Link to this heading">#</a></h3>
</section>
</section>
<section id="extended-reading">
<h2>Extended Reading<a class="headerlink" href="#extended-reading" title="Link to this heading">#</a></h2>
<div class="docutils container" id="id4">
<div role="list" class="citation-list">
<div class="citation" id="id10" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">ABjorck73</a><span class="fn-bracket">]</span></span>
<p>Ned Anderson and Åke Björck. A new high order method of regula falsi type for computing a root of an equation. <em>BIT Numerical Mathematics</em>, 13(3):253–264, 1973.</p>
</div>
<div class="citation" id="id8" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">DJ72</a><span class="fn-bracket">]</span></span>
<p>M Dowell and P Jarratt. The “pegasus” method for computing the root of an equation. <em>BIT Numerical Mathematics</em>, 12:503–508, 1972.</p>
</div>
<div class="citation" id="id9" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">Kin73</a><span class="fn-bracket">]</span></span>
<p>Richard F King. An improved pegasus method for root finding. <em>BIT Numerical Mathematics</em>, 13:423–427, 1973.</p>
</div>
</div>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="floating_point.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Floating Point Arithmetic</p>
      </div>
    </a>
    <a class="right-next"
       href="interpolation.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Interpolation</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#bracket-methods">Bracket Methods</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bisection-method">Bisection Method</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#false-position-method">False Position Method</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#order-of-convergence">Order of Convergence</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#iterative-methods">Iterative Methods</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#newton-raphson-method">Newton-Raphson Method</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#secant-method">Secant Method</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#applications-in-optimization">Applications in Optimization</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">Exercises</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#theoretical-part">Theoretical Part</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#computational-part">Computational Part</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#extended-reading">Extended Reading</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Yimin Zhong
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>