%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[letterpaper,10pt,english]{jupyterBook}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\setmainfont[ Path = ../../font/, UprightFont = *-Regular,BoldFont = *-Bold,ItalicFont = *-Italic]{GentiumBookPlus}\setsansfont[ Path = ../../font/, UprightFont = *-Regular,BoldFont = *-Bold,ItalicFont = *-Italic]{GentiumBookPlus}
\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Lecture notes}}

\usepackage{sphinxmessages}


\newcommand\N{\mathbb{N}}
\newcommand\floor[1]{\lfloor#1\rfloor}
\newcommand{\bmat}{\left[\begin{array}}
\newcommand{\emat}{\end{array}\right]}

        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
        \hypersetup{
            pdfencoding=auto,
            psdextra
        }
        % End of preamble defined in sphinx-jupyterbook-latex %
        

\title{Introduction to Numerical Analysis I}
\date{Feb 16, 2024}
\release{}
\author{Yimin Zhong}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxAtStartPar
This repository hosts the course material for Math 5630/6630: \sphinxstylestrong{Introduction to Numerical Analysis I} at Auburn University. The course will use the textbook written by A. Quarteroni, R. Saaco, and F. Saleri, \sphinxstyleemphasis{Numerical Mathematics}, Second Edition, Springer, New York, 2007.

\sphinxAtStartPar
The course will cover the following topics:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Floating point arithmetic

\item {} 
\sphinxAtStartPar
Root finding

\item {} 
\sphinxAtStartPar
Interpolation and approximation

\item {} 
\sphinxAtStartPar
Numerical differentiation and integration

\item {} 
\sphinxAtStartPar
Numerical solutions of ordinary differential equations

\end{itemize}

\sphinxAtStartPar
This course is an introduction to numerical analysis. It is designed to provide a solid foundation in numerical methods and their applications.   Both fundamental theory and programming are required throughout the course. The prerequisites for the theory part are
\begin{itemize}
\item {} 
\sphinxAtStartPar
Linear Differential Equations (2650)

\item {} 
\sphinxAtStartPar
Topics in Linear Algebra (2660)

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The default programming language for this class is \sphinxcode{\sphinxupquote{Python}} and \sphinxcode{\sphinxupquote{MATLAB}}, the other script languages such as \sphinxcode{\sphinxupquote{R}}, \sphinxcode{\sphinxupquote{Julia}} are also supported.
\end{sphinxadmonition}

\sphinxstepscope


\chapter{Floating Point Arithmetic}
\label{\detokenize{floating_point:floating-point-arithmetic}}\label{\detokenize{floating_point::doc}}
\sphinxAtStartPar
In this chapter, we will introduce some basics on the real number system for modern computers and discuss the arithmetic operations of the number system.


\section{Representation of Real Numbers}
\label{\detokenize{floating_point:representation-of-real-numbers}}
\sphinxAtStartPar
Any nonzero real number \(x\in \mathbb{R}\) can be accurately represented with an infinite sequence of digits. This can be understood as the consequence that rational numbers are \sphinxstylestrong{dense} on any interval.

\begin{sphinxShadowBox}
\sphinxstylesidebartitle{\sphinxstylestrong{What does “dense” mean?}}

\sphinxAtStartPar
\sphinxstylestrong{Dense} means that between any two distinct real numbers, there is always a rational number. It is a fundamental property of the real number system.
\end{sphinxShadowBox}

\sphinxAtStartPar
Therefore, with the binary representation, we can write
\begin{equation*}
\begin{split}
x = \pm (0.d_1 d_2 d_3\dots d_{t-1} d_t d_{t+1}\dots) \times 2^e,
\end{split}
\end{equation*}
\sphinxAtStartPar
where \(e\) is an integer exponent and \(d_1=1\), the other binary digits \(d_i\in \{0, 1\}\). The mantissa part
\begin{equation*}
\begin{split}
0.d_1 d_2 d_3\dots =  \frac{d_1}{2} + \frac{d_2}{2^2} + \frac{d_3}{2^3} + \cdots.
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
In order to guarantee the uniqueness of the above representation, we need further assumption that there exists an infinite subset \(S\subset \mathbb{N}\) that \(d_j\neq 1\) for \(j\in S\). For example, under binary representation
\begin{equation*}
\begin{split}0.111\dots = (0.1)\times 2^1,\end{split}
\end{equation*}
\sphinxAtStartPar
then we will take the latter representation.
\end{sphinxadmonition}


\section{Floating Point Numbers}
\label{\detokenize{floating_point:floating-point-numbers}}
\sphinxAtStartPar
The floating point numbers generally refer to a set of real numbers with \sphinxstylestrong{finite} mantissa length. More precisely, we consider the set of real numbers \(\mathbb{F} = \mathbb{F}(t, e_{\min}, e_{\max})\subset \mathbb{R}\) that
\begin{equation*}
\begin{split}\mathbb{F} := \{x\in \mathbb{R} \mid x = \pm (0.d_1 d_2 d_3\dots d_{t-1} d_t) \times 2^e, d_1 =1,  e_{\min}\le e\le e_{\max}\}\cup \{0\}.\end{split}
\end{equation*}
\sphinxAtStartPar
It can be seen that there are only finite numbers in \(\mathbb{F}\) with the smallest positive element \(x_{\min} = 2^{e_{\min}-1}\) and the largest element \(x_{\max} = ( 1- 2^{-t} )\times 2^{e_{\max} }\). Therefore
\begin{equation*}
\begin{split}\mathbb{F}\subset \overline{\mathbb{F}}:= \{ x\in \mathbb{R}\mid x_{\min} \le |x| \le x_{\max}\}\cup \{ 0\}.\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The elements in \(\mathbb{F}\) are called normalized. If we  allow \(d_1 = 0\) in the definition of \(\mathbb{F}\), then the numbers in the set are called denormalized.
\end{sphinxadmonition}
\label{floating_point:THM-Di-Fl-Nu}
\begin{sphinxadmonition}{note}{Theorem 1 (Distribution of Floating Numbers)}



\sphinxAtStartPar
For any \(e_{\min} \le e\le e_{\max}\), the distribution of the floating point number system \(\mathbb{F}\) on interval \([2^{e-1}, 2^e]\) is equidistant with distances of length \(2^{e-t}\).
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}
\sphinxAtStartPar
Proof. For any  \(x \in \mathbb{F}\cap [2^{e-1}, 2^e]\), it can be represented by
\begin{equation*}
\begin{split}x = (0.d_1d_2\dots d_t)\times 2^{e}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(d_1 = 1\). The mantissa is equidistantly distributed with distance \(2^{-t}\), therefore the floating point numbers are equidistantly distributed with distances of length \(2^{e-t}\).
\end{sphinxadmonition}

\sphinxAtStartPar
To understand the approximation to real numbers by the floating point number system \(\mathbb{F}\), it is important to consider the maximal relative distance between the numbers in \(\overline{\mathbb{F}}\) and their respective closest element in \(\mathbb{F}\), which is the following quantity:
\begin{equation*}
\begin{split}\max_{x\in \overline{\mathbb{F}}, x\neq 0}\min_{z\in\mathbb{F}} \frac{|z - x|}{|x|}.\end{split}
\end{equation*}
\sphinxAtStartPar
The following holds:
\label{floating_point:THM-Ma-Pr}
\begin{sphinxadmonition}{note}{Theorem 2 (Machine Precision)}


\begin{equation*}
\begin{split}\max_{x\in \overline{\mathbb{F}}, x\neq 0}\min_{z\in\mathbb{F}} \frac{|z - x|}{|x|}\le  2^{-t}.\end{split}
\end{equation*}
\sphinxAtStartPar
The number \(\mathrm{u} := 2^{-t}\) is also called rounding unit or machine precision.
\end{sphinxadmonition}

\begin{sphinxShadowBox}
\sphinxstylesidebartitle{}

\sphinxAtStartPar
The definition of machine precision has two versions. The formal definition \(2^{-t}\) appears mostly in research literature and numerical packages (LAPACK). In modern programming languages like \sphinxcode{\sphinxupquote{Python}}, \sphinxcode{\sphinxupquote{MATLAB}}, \sphinxcode{\sphinxupquote{C++}}, the machine precision is defined by \(2^{t-1}\) instead. The meaning is the \sphinxstylestrong{difference} between one and the next floating point number.

\sphinxAtStartPar
In other words, two versions of machine precision are corresponding to different rounding strategies. For the former, the rounding strategy is to round to the nearest floating point number, while for the latter, the rounding strategy is to round\sphinxhyphen{}by\sphinxhyphen{}chop.

\sphinxAtStartPar
In practice, it is not necessary to distinguish the two versions of machine precision, since the difference is only a factor of 2.
\end{sphinxShadowBox}

\begin{sphinxadmonition}{note}
\sphinxAtStartPar
Proof. Without loss of generality, we only need to consider the positive numbers in \(\overline{\mathbb{F}}\), then one can represent any nonzero \(x\in [x_{\min}, x_{\max}]\) by
\begin{equation*}
\begin{split}x = (0.d_1 d_2 \dots d_t\dots)\times 2^e\in [2^{e-1}, 2^e].\end{split}
\end{equation*}
\sphinxAtStartPar
Since the floating point numbers are equidistantly distributed on \([2^{e-1}, 2^e]\) from {\hyperref[\detokenize{floating_point:THM-Di-Fl-Nu}]{\sphinxcrossref{Theorem 1}}}, one can find \(z^{\ast}\in\mathbb{F}\) such that
\begin{equation*}
\begin{split}|z^{\ast} - x| \le \frac{1}{2} 2^{e-t},\end{split}
\end{equation*}
\sphinxAtStartPar
therefore
\begin{equation*}
\begin{split}\frac{|z^{\ast}- x|}{|x|}\le \frac{1}{2} 2^{e-t} \frac{1}{2^{e-1}} = 2^{-t}.\end{split}
\end{equation*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
On modern computers, the following two floating point number systems
\begin{equation*}
\begin{split}\mathbb{F}_{32} := \mathbb{F}(24, -125, 128),\quad\mathbb{F}_{64} := \mathbb{F}(53, -1021, 1024)\end{split}
\end{equation*}
\sphinxAtStartPar
are supported, they are often called single precision and double precision, respectively.
\end{sphinxadmonition}

\begin{sphinxShadowBox}
\sphinxstylesidebartitle{\sphinxstylestrong{IEEE754 Standard}}

\sphinxAtStartPar
The IEEE754 standard for floating point arithmetic is slightly different from the note. For instance, without \sphinxstylestrong{underflow} (all exponent bits are zeros), the standard \sphinxcode{\sphinxupquote{float32}} is represented as
\begin{equation*}
\begin{split}\pm 1.d_1 d_2\cdots d_{23} \times 2^e\end{split}
\end{equation*}
\sphinxAtStartPar
where the sign occupies 1 bit, the mantissa occupies 23 bits, and the exponent occupies 8 bits, ranging from \(-126\) to \(127\) instead. The floating number is stored as
\begin{equation*}
\begin{split}\text{sign} \mid e_7 e_6 \cdots e_0 \mid d_1 d_2\cdots d_{23}\end{split}
\end{equation*}
\sphinxAtStartPar
and \(e = \sum_{j=0}^7 2^{j} e_j - 127\).
\end{sphinxShadowBox}


\section{Rounding}
\label{\detokenize{floating_point:rounding}}
\sphinxAtStartPar
The rounding operation \(\textrm{fl}\) is to map any real numbers of \(\overline{\mathbb{F}}\) into the floating point number system \(\mathbb{F}\) with smallest error. Such rounding operation can be written out explicitly, let \(x = \pm (0.d_1 d_2\dots d_t d_{t+1}\dots )\times 2^e\), then
\begin{equation*}
\begin{split}
    \textrm{fl}(x) =\begin{cases}
        \pm (0.d_1 d_2\dots d_t) \times 2^e & \text{if } d_{t+1} = 0,\\
        \pm (0.d_1 d_2\dots d_t  + 2^{-t}) \times 2^e & \text{if } d_{t+1} = 1.
    \end{cases}
\end{split}
\end{equation*}
\sphinxAtStartPar
It is clear that rounding \(\textrm{fl}\) is monotone and idempotent, which means
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(x\le y \Rightarrow \textrm{fl}(x) \le \textrm{fl}(y)\).

\item {} 
\sphinxAtStartPar
\(\textrm{fl}(z) = z\) if \(z\in \mathbb{F}\).

\end{itemize}
\label{floating_point:THM-REL-ERR}
\begin{sphinxadmonition}{note}{Theorem 3}



\sphinxAtStartPar
For any \(x\in \overline{\mathbb{F}}\), \(|\textrm{fl}(x) - x| = \min_{z\in \mathbb{F}} |z - x|\). If \(x\neq 0\), then
\begin{equation*}
\begin{split}\frac{|\textrm{fl}(x) - x|}{|x|}\le \mathrm{u} = 2^{-t}.\end{split}
\end{equation*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}
\sphinxAtStartPar
Proof. The special case that \(x = 0\) is trivial, we only consider \(x\in [x_{\min}, x_{\max}]\), it can be seen that
\begin{equation*}
\begin{split}
    |\textrm{fl}(x) - x| = | (0.d_1d_2\dots \tilde{d}_t) - (0.d_1d_2\dots d_t d_{t+1} \dots )|\times 2^e \le 2^{-(t+1)} \times 2^e,
\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\tilde{d}_t\) is the rounding bit, therefore
\begin{equation*}
\begin{split}
    \frac{|\textrm{fl}(x) - x|}{|x|} \le \frac{2^{e-(t+1)}}{2^{e-1}} = 2^{-t}.
\end{split}
\end{equation*}\end{sphinxadmonition}
\label{floating_point:COR-REL-ERR}
\begin{sphinxadmonition}{note}{Corollary 1}



\sphinxAtStartPar
For any \(x\in\overline{\mathbb{F}}\), \(\textrm{fl}(x) = x(1+\delta)\) with \(|\delta|\le \mathrm{u}\).
\end{sphinxadmonition}






\renewcommand{\indexname}{Proof Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{COR\sphinxhyphen{}REL\sphinxhyphen{}ERR}
\item\relax\sphinxstyleindexentry{COR\sphinxhyphen{}REL\sphinxhyphen{}ERR}\sphinxstyleindexextra{floating\_point}\sphinxstyleindexpageref{floating_point:\detokenize{COR-REL-ERR}}
\indexspace
\bigletter{THM\sphinxhyphen{}Di\sphinxhyphen{}Fl\sphinxhyphen{}Nu}
\item\relax\sphinxstyleindexentry{THM\sphinxhyphen{}Di\sphinxhyphen{}Fl\sphinxhyphen{}Nu}\sphinxstyleindexextra{floating\_point}\sphinxstyleindexpageref{floating_point:\detokenize{THM-Di-Fl-Nu}}
\indexspace
\bigletter{THM\sphinxhyphen{}Ma\sphinxhyphen{}Pr}
\item\relax\sphinxstyleindexentry{THM\sphinxhyphen{}Ma\sphinxhyphen{}Pr}\sphinxstyleindexextra{floating\_point}\sphinxstyleindexpageref{floating_point:\detokenize{THM-Ma-Pr}}
\indexspace
\bigletter{THM\sphinxhyphen{}REL\sphinxhyphen{}ERR}
\item\relax\sphinxstyleindexentry{THM\sphinxhyphen{}REL\sphinxhyphen{}ERR}\sphinxstyleindexextra{floating\_point}\sphinxstyleindexpageref{floating_point:\detokenize{THM-REL-ERR}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}